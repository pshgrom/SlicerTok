# Рекомендации по улучшению проекта SlicerTok

Анализ по направлениям: архитектура, производительность, масштабируемость, лучшие практики.

---

## 1. Architecture

### 1.1 Единообразная ленивая загрузка маршрутов

**Проблема:** Часть страниц подключается статически (`import Landing from '@/pages/landing'`), часть — лениво (`() => import('@/pages/terms')`). Статические импорты попадают в главный бандл и увеличивают время первой загрузки.

**Где:** `src/app/router/index.ts` — Landing, LoginView, LoginViewAdmin, Streamer, UserInfo, AdminInfo, SupportPage импортируются напрямую.

**Рекомендация:** Все страницы загружать лениво:

```ts
{
  path: '/',
  name: 'Landing',
  component: () => import('@/pages/landing'),
  meta: { showChat: false }
},
{
  path: '/login',
  name: 'Login',
  component: () => import('@/pages/login'),
  meta: { showChat: false }
},
// ... аналогично для Streamer, UserInfo, AdminInfo, SupportPage, LoginViewAdmin
```

Использовать единый паттерн имён чанков при необходимости (уже есть `page_*` в `manualChunks`).

---

### 1.2 Слой Features (опционально)

**Текущее состояние:** Есть app, entities, pages, widgets, shared. Нет слоя **features** — сценарии использования размазаны по страницам и виджетам.

**Рекомендация:** При росте числа сценариев ввести `src/features/`: один фича = один сценарий (например, «отправить на выплату», «завершить модерацию»). Фича использует entities и экспортирует UI/композабл. Страницы тогда только собирают фичи и виджеты. Пока можно отложить и вводить по мере дублирования логики между страницами.

---

### 1.3 Централизованная обработка ошибок API

**Проблема:** В каждом store повторяется один и тот же блок:

```ts
} catch (error: unknown) {
  const axiosError = error as AxiosError<{ message?: string }>
  errorStore.setErrors(axiosError.response?.data?.message ?? '')
}
```

Уже есть `handleApiError()` в `@/shared/lib/utils/errorHandler.ts`, но он используется только в `LoginViewAdmin`.

**Рекомендация:** Использовать `handleApiError` во всех entity-stores:

```ts
import { useError } from '@/app/stores'
import { handleApiError } from '@/shared/lib'

// в catch:
} catch (error: unknown) {
  errorStore.setErrors(handleApiError(error))
}
```

При необходимости расширить `handleApiError` (например, поддержка `error.response?.data?.errors` или кодов).

---

### 1.4 Глобальный перехватчик ошибок axios (опционально)

**Проблема:** Ошибки обрабатываются только в catch в каждом вызове. При забытом catch пользователь может не увидеть сообщение.

**Рекомендация:** В `shared/api/instance.ts` в response interceptor при 4xx/5xx вызывать `useError().setErrors(...)` с текстом из `handleApiError(error)`, а в stores при необходимости только отменять повторный показ или дополнять логику. Тогда один раз настроенная обработка будет работать для всех запросов.

---

### 1.5 Валидация env при старте

**Проблема:** `VITE_API_BASE_URL` и `VITE_BASE_URL` используются без проверки. При отсутствии переменных приложение может падать в рантайме.

**Рекомендация:** Добавить валидацию при инициализации (например, в `main.ts` или в `shared/config/env.ts`):

```ts
const requiredEnv = ['VITE_API_BASE_URL'] as const
for (const key of requiredEnv) {
  if (!import.meta.env[key]) {
    console.error(`Missing env: ${key}`)
    // в dev — показать ошибку; в prod — не ломать или показать fallback
  }
}
```

Или использовать библиотеку вроде `zod` для `import.meta.env` и типизированного объекта конфига.

---

## 2. Performance

### 2.1 Lazy-загрузка страниц (см. п. 1.1)

Перевод всех маршрутов на `() => import(...)` уменьшит размер начального бандла и ускорит первый рендер.

---

### 2.2 Загрузка стримеров в guard

**Проблема:** В `router.beforeEach` при наличии токена всегда вызывается `streamers.getStreamerList()`, если список ещё не загружен. Это выполняется при каждом переходе, пока флаг не установится.

**Рекомендация:** Оставить как есть, но убедиться, что запрос не дублируется (например, флаг `streamersLoaded` сбрасывается только при logout). При необходимости кэшировать результат с TTL.

---

### 2.3 Модалки и тяжёлые виджеты

**Текущее состояние:** Часть модалок уже через `defineAsyncComponent` (например, в таблицах). Это хорошо.

**Рекомендация:** Проверить, что все крупные модалки и редко показываемые экраны загружаются асинхронно (например, `TwoFactorAuth`, тяжёлые диалоги в админке). При необходимости вынести их в отдельные чанки в `manualChunks`.

---

### 2.4 Таблицы с большим количеством строк

**Проблема:** `v-data-table` с тысячами строк может тормозить из‑за полного рендера DOM.

**Рекомендация:** При появлении реальных больших списков рассмотреть виртуализацию (например, `vue-virtual-scroller` или встроенные возможности Vuetify 3, если есть) или серверную пагинацию с ограничением `perPage`.

---

### 2.5 Анализ бандла

**Текущее состояние:** В конфиге есть `ANALYZE=true vite build` и `rollup-plugin-visualizer`.

**Рекомендация:** Периодически запускать `npm run analyze` и смотреть, какие пакеты/модули дают большой вес (особенно vendor_vuetify, vendor_chart). При необходимости подключать тяжёлые библиотеки только на нужных маршрутах (dynamic import).

---

## 3. Scalability

### 3.1 Типизация вместо Record<string, unknown>

**Проблема:** В stores и API часто используется `Record<string, unknown>`, `(res?.data as Record<string, unknown>)` и т.п. Это усложняет рефакторинг и поиск ошибок.

**Рекомендация:** Ввести DTO/типы ответов API по сущностям (например, в `entities/<entity>/api/types.ts` или в `shared/config/types`). Типизировать ответы в `api.ts` и данные в store (например, `items: ref<IPayoutListItem[]>` вместо `Record<string, unknown>[]`). Делать постепенно при касании модуля.

---

### 3.2 Документирование границ слоёв

**Рекомендация:** Добавить короткий `docs/ARCHITECTURE.md` (или раздел в README): какие папки за что отвечают, кто кого может импортировать (например, entities не импортируют pages/widgets; shared не импортирует app/entities/pages/widgets). Это поможет сохранять консистентность при росте команды.

---

### 3.3 Barrel-файлы и tree-shaking

**Проблема:** Крупные barrel-файлы (`shared/lib/index.ts`, `shared/ui/index.ts`) реэкспортируют много модулей. При импорте одного композабла бандлер может подтянуть весь индекс (зависит от настройки).

**Рекомендация:** Оставить barrel для удобства, но при росте размера shared рассмотреть импорты напрямую из файлов для критичных к размеру бандла мест (например, `import { useTableQuery } from '@/shared/lib/composables/useTableQuery'`). Проверять влияние через `npm run analyze`.

---

### 3.4 Роутинг и роли

**Текущее состояние:** Роли и маршруты заданы в `ROLES` и `redirectByRole`; в `beforeEach` проверяется `meta.roles`.

**Рекомендация:** При добавлении новых ролей/маршрутов держать конфиг маршрутов и прав в одном месте (например, массив маршрутов с `meta.roles` и отдельный маппинг «роль → дефолтный маршрут»). Это упростит масштабирование и поддержку.

---

## 4. Best practices

### 4.1 Тестирование

**Проблема:** В проекте нет тестов (нет `*.spec.*`, `*.test.*`).

**Рекомендация:** Подключить Vitest для unit-тестов (композаблы, утилиты, store-actions) и при необходимости Playwright/Cypress для критичных E2E-сценариев. Начать с самых важных: авторизация, платёжные сценарии, модерация.

---

### 4.2 Сокращение использования any

**Проблема:** В коде есть использование `any` (например, в таблицах, в `showViolations`, в части страниц).

**Рекомендация:** Включать в ESLint правило `@typescript-eslint/no-explicit-any` (warn или error) и по мере правок заменять на конкретные типы или `unknown` с type guard.

---

### 4.3 Pinia: вызов других stores

**Проблема:** В некоторых stores другие stores вызываются на верхнем уровне (при инициализации), например `const errorStore = useError()`. Это затрудняет unit-тесты (нужно мокать все такие stores).

**Рекомендация:** По возможности вызывать `useError()` и т.п. внутри действий, а не в корне setup. Либо оставить как есть и в тестах инициализировать Pinia с подменёнными stores.

---

### 4.4 Консистентность именования

**Текущее состояние:** Есть опечатка в имени компонента `VCusomButton` (должно быть `VCustomButton`). Используется в проекте повсеместно.

**Рекомендация:** Переименовать в `VCustomButton` и обновить все импорты (поиск по проекту). Либо зафиксировать текущее имя в style guide, чтобы не путаться.

---

### 4.5 Лоадер в навигации

**Текущее состояние:** В `afterEach` вызывается `setTimeout(() => loader.stop(), 200)`. Фиксированная задержка может быть избыточной или недостаточной в зависимости от сети.

**Рекомендация:** Рассмотреть отключение лоадера по факту завершения перехода и загрузки данных страницы (например, когда страница вызовет `loader.stop()` после своего `onMounted`/запроса) или использовать минимальную задержку только для скелетона, чтобы избежать мелькания.

---

## Приоритизация

| Приоритет | Что сделать |
|-----------|-------------|
| Высокий   | Ленивая загрузка всех страниц в router (1.1, 2.1). |
| Высокий   | Единая обработка ошибок через `handleApiError` в stores (1.3). |
| Средний   | Валидация env (1.5). Типизация API/stores (3.1) по мере рефакторинга. |
| Средний   | Документация архитектуры (3.2). Включить no-explicit-any (4.2). |
| Низкий    | Слой features (1.2). Глобальный axios interceptor (1.4). Тесты (4.1). Переименование VCusomButton (4.4). |

Файл можно использовать как чек-лист и дополнять по мере внедрения изменений.
